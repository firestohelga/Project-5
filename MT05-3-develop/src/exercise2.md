# Архитектура.

## Уровни уровней веб-приложений.

**Уровень представления** -
PL отображает пользовательский интерфейс и упрощает взаимодействие с пользователем. Уровень представления имеет компоненты пользовательского интерфейса, которые визуализируют и показывают данные для пользователей. Также существуют компоненты пользовательского процесса, которые задают взаимодействие с пользователем. PL предоставляет всю необходимую информацию клиентской стороне. Основная цель уровня представления - получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты.  
**Слой бизнес-логики** -
BLL несет ответственность за надлежащий обмен данными. Этот уровень определяет логику бизнес-операций и правил. Он обрабатывает запросы браузера, выполняет бизнес-логику, связанную с запросами, а затем отправляет их на уровень представления.  
**Уровень обслуживания данных** -
DSL тесно связан с бизнес-уровнем и имеет сервер базы данных, который извлекает данные с соответствующих серверов. Передает данные, обработанные уровнем бизнес-логики, на уровень представления. Этот уровень гарантирует безопасность данных, изолируя бизнес-логику со стороны клиента.  
**Уровень доступа к данным** - 
DAL Уровень базы данных или уровень службы данных содержит все данные и обеспечивает безопасность данных, отделяя бизнес-логику от клиентской стороны. Предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Уровень доступа к данным также управляет операциями CRUD - создание, чтение, обновление, удаление.

## Монолитная и микросервисная архитектура веб-приложений

**Монолитная архитектура**  — это традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений. Монолитом часто называют нечто большое и неповоротливое, и эти два слова хорошо описывают монолитную архитектуру для проектирования ПО. *Монолитная архитектура* — это отдельная большая вычислительная сеть с единой базой кода, в которой объединены все бизнес-задачи. Чтобы внести изменения в такое приложение, необходимо обновить весю структуру через базу кода, а также создать и развернуть обновленную версию интерфейса, находящегося на стороне службы. Это ограничивает работу с обновлениями и требует много времени.

**Микросервисная архитектура** - представляет собой метод организации архитектуры, основанный на ряде независимо развертываемых служб. У этих служб есть собственная бизнес-логика и база данных с конкретной целью. Обновление, тестирование, развертывание и масштабирование выполняются внутри каждой службы. Микросервисы разбивают крупные задачи, характерные для конкретного бизнеса, на несколько независимых баз кода. Микросервисы не снижают сложность, но они делают любую сложность видимой и более управляемой, разделяя задачи на более мелкие процессы, которые функционируют независимо друг от друга и вносят вклад в общее целое.

## Различия архитектур.

Преимущество разработки приложения, которое следует *микросервисной архитектуре*, заключается в том, что разработчики имеют широкий спектр возможностей для различных технологий, таких как операционные системы, платформы, языки программирования и т.д., для создания приложения.   
В *монолитной архитектуре* разработчики вынуждены использовать только одну технологию, независимо от ее ограничений.  
В *микросервисной архитектуре* даже если в каком-либо из процессов возникнет ошибка, остальные процессы не будут затронуты и могут быть запущены, поскольку все сервисы независимы и изолированы друг от друга.  
В *монолитный архитектуре* напротив, любой вид неправильного поведения в любом из компонентов может серьезно повлиять на работу всего приложения.  
В *микросервисной архитектуре* используется  разделенная кодовая база. Кодовые базы в микросервисах разбиты на несколько блоков кода, что облегчает управление и обновление.   
В *монолитный архитектуре* используется только одна кодовая база. Из-за большого размера монолитных кодовых баз, командам разработчиков очень трудно понять и правильно управлять ими, это также приводит к замедлению процессов развития.   
В *микросервисной архитектуре* разработка, развертывание, эксплуатация и масштабирование каждого компонента приложения Microservices являются независимым, любое обновление в любых сервисах приложения не повлияет на другие сервисы. Кроме того, между службами нет разделения реализации или кодовой базы. Это приводит к легкости непрерывной разработки и развертывания сложных и огромных приложений.
В *монолитный архитектуре* кодовые базы большие, а компоненты взаимозависимы, это приводит к ограничению непрерывного развертывания и разработки, поскольку для обновления любого компонента необходимо повторно развернуть полное приложение. Это рискованно и затрагивает все фоновые задачи, а также влияют на связанные сервисные функции.
В *микросервисной архитектуре* все сервисы приложений построены как разные модули, это приводит к разделению команды на различную работу, что дополнительно помогает им легко менять и обновлять производство. Это облегчает масштабирование приложения.
В *монолитный архитектуре* масштабирование приложений является сложной задачей для разработчиков, поскольку представляет собой единое целое. Разработчики не могут работать над отдельными модулями. Если это возможно, потребуется тяжелая координация во время развертывания и разработки.

## Существует несколько причин, почему не все приложения построены на микросервисной архитектуре:

1. Сложность разработки: Микросервисная архитектура требует большого количества работы для ее настройки и поддержания. Не все компании могут позволить себе такой уровень сложности.

2. Низкая степень модульности: Некоторые приложения не могут быть разбиты на отдельные сервисы из-за своей структуры и функционала.

3. Необходимость высокой производительности: В некоторых случаях, использование микросервисной архитектуры может привести к увеличению задержек и снижению производительности.

4. Недостаточность ресурсов: Для работы микросервисной архитектуры требуется большое количество ресурсов, включая сервера, базы данных и средства управления.

5. Сложность интеграции: Интеграция микросервисов может быть сложной, особенно если они разработаны на разных языках программирования или используют различные протоколы связи.

В целом, нельзя сказать, что какой-то подход лучше другого, ведь выбор между монолитной и микросервисной архитектурой зависит от конкретных потребностей и возможностей компани.

## Монолитные и микросервисные веб-приложения имеют свои особенности в тестировании. 

- Для монолитных приложений тестирование может быть проще, так как все компоненты приложения находятся в одном месте и интеграция происходит внутри одной системы. В свою очередь, микросервисные приложения имеют несколько частей, которые необходимо интегрировать и проверить, что они работают корректно. 

- При тестировании монолитного приложения может использоваться классический подход к тестированию (unit, integration, system testing), а для микросервисных приложений необходимо использовать новые методы, такие как сервисное тестирование и интеграционное тестирование. 

- Для микросервисных приложений важно уделять большое внимание тестированию API, так как это ключевой механизм взаимодействия между сервисами. 

- Также, для микросервисных приложений может быть более сложно обеспечить полное покрытие всех сервисов тестами, так как их количество может быть очень большим. 

В целом, тестирование монолитных и микросервисных веб-приложений отличаются, но для обеих архитектур важно обеспечить надежность и безопасность приложения.